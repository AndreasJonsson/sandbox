<?xml version="1.0" encoding="UTF-8"?>

<xwikidoc>
<web>AnnotationCode</web>
<name>Script</name>
<language></language>
<defaultLanguage></defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>XWiki.Admin</creator>
<author>XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>XWiki.Admin</contentAuthor>
<creationDate>1264860755000</creationDate>
<date>1265812097000</date>
<contentUpdateDate>1265812097000</contentUpdateDate>
<version>1.0</version>
<title></title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<object>
<class>
<name>XWiki.JavaScriptExtension</name>
<customClass></customClass>
<customMapping></customMapping>
<defaultViewSheet></defaultViewSheet>
<defaultEditSheet></defaultEditSheet>
<defaultWeb></defaultWeb>
<nameField></nameField>
<validationScript></validationScript>
<cache>
<cache>0</cache>
<displayType>select</displayType>
<multiSelect>0</multiSelect>
<name>cache</name>
<number>5</number>
<prettyName>Caching policy</prettyName>
<relationalStorage>0</relationalStorage>
<separator> </separator>
<separators> ,|</separators>
<size>1</size>
<unmodifiable>0</unmodifiable>
<values>long|short|default|forbid</values>
<classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
</cache>
<code>
<name>code</name>
<number>2</number>
<prettyName>Code</prettyName>
<rows>20</rows>
<size>50</size>
<unmodifiable>0</unmodifiable>
<classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
</code>
<name>
<name>name</name>
<number>1</number>
<prettyName>Name</prettyName>
<size>30</size>
<unmodifiable>0</unmodifiable>
<classType>com.xpn.xwiki.objects.classes.StringClass</classType>
</name>
<parse>
<displayFormType>select</displayFormType>
<displayType>yesno</displayType>
<name>parse</name>
<number>4</number>
<prettyName>Parse content</prettyName>
<unmodifiable>0</unmodifiable>
<classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
</parse>
<use>
<cache>0</cache>
<displayType>select</displayType>
<multiSelect>0</multiSelect>
<name>use</name>
<number>3</number>
<prettyName>Use this extension</prettyName>
<relationalStorage>0</relationalStorage>
<separator> </separator>
<separators> ,|</separators>
<size>1</size>
<unmodifiable>0</unmodifiable>
<values>onDemand=On demand|always=Always</values>
<classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
</use>
</class>
<name>AnnotationCode.Script</name>
<number>0</number>
<className>XWiki.JavaScriptExtension</className>
<guid>046e135f-7fed-40ec-a51d-c01ec1ac25e6</guid>
<property>
<cache></cache>
</property>
<property>
<code>if (typeof (XWiki) == 'undefined') {
    XWiki = new Object();
}
 
XWiki.Selection = Class.create({
  container : false,
  selectionText : false,
  selectionContext : false,
  selectionOffset : false,
  // the selection range
  range : false,
  // the element that wraps the selection to make it colored, in FF
  highlightWrapper : false,
  // the parent of the selection and the selection inner HTML to make it colored in FF and to be able to rollback this change
  selectionParent : false,
  selectionParentInnerHTML : false,
  // position of the last mouse up, to know where to display the dialog
  offsetX : false,
  offsetY : false,
  // how many characters to expand left &amp; right on ff
  step : 5,
  // how may words to expand left &amp; right on IE
  wordStep : 1,

  initialize : function (container) {
    this.container = container;
    // on IE we listen to the mousedown and remember the position of the mousedown of the selection to know where to display the dialog for annotation creation
    if (!window.getSelection) {
      this.container.observe('mousedown', function(event) {
        this.offsetX = event.offsetX;
        this.offsetY = event.offsetY;
      }.bindAsEventListener(this));
    }
  },

  computeSelection : function () {
    // reset the selection state
    this.selectionText = false;
    this.range = false;
    this.selectionContext = false;
    this.selectionOffset = false;
    this.highlightWrapper = false;
    this.selectionParent = false;
    this.selectionParentInnerHTML = false;
    if (window.getSelection) { 
      // FF selection &amp; hopefully other browsers 
      this.range = window.getSelection().getRangeAt(0);
      // ignore if the selection is in the passed container
      if (!this.isDescendantOrSelf(this.container, this.range.commonAncestorContainer)) {
        return;
      }
      this.selectionText = this.range.toString();
    } else {
      // IE selection
      if (document.selection.type == 'Text') {
        this.range = document.selection.createRange();
        // ignore if the selection is in the passed container
        if (!this.isDescendantOrSelf(this.container, this.range.parentElement())) {
          return;
        }
        this.selectionText = this.range.text;
      }
    }
    if (this.selectionText == '') {
      this.selectionText = false;
    }
  },

  isDescendantOrSelf : function(ancestor, descendant) {
    return ancestor == descendant || Element.descendantOf(descendant, ancestor); 
  },

  computeContext : function() {
    if (window.getSelection) {
      this.computeContextFF();
    } else {
      this.computeContextIE();
    }
  },

  // these functions are here because they depend on selection

  highlightSelection : function(color) {
    if (!this.range) {
      // there should be some selection at this point
      return;
    }
    if (window.getSelection) {
      // standard
      // create an annotation highlight span around this content
      this.highlightWrapper = new Element('span', {'style': 'background-color: ' + color, 'id' : 'selection-highlight'});
      // surround the selection with the highlighted span
      // TODO: this doesn't work if content of selection is not inline (or anything else but text)
      this.range.surroundContents(this.highlightWrapper);
    } else {
      // IE
      // get the selection parent and its inner HTML to be able to restore it after
      this.selectionParent = this.range.parentElement();
      this.selectionParentInnerHTML = this.selectionParent.innerHTML;
      // and finally color it
      this.range.execCommand("BackColor", false, color);
    }
  },

  removeSelectionHighlight : function() {
    if (window.getSelection) {
      // standard
      // unwrap
      this.highlightWrapper.replace(this.highlightWrapper.innerHTML);
    } else {
      // IE
      this.selectionParent.update(this.selectionParentInnerHTML);
    }
  },

  positionPanelNextToSelection : function(panel) {
    if (!this.range) {
      return;
    }

    if (window.getSelection) {
      // set the position
      panel.style.left = this.highlightWrapper.positionedOffset().left + "px";
      panel.style.top = (this.highlightWrapper.positionedOffset().top + this.highlightWrapper.getHeight())+ "px";
    } else {
      panel.style.left = this.offsetX + "px";
      panel.style.top = this.offsetY + "px";
    }
  },

  /*
   * I don't understand what's under here, I will need to review it
   */
  getRightDocument : function(node) {
    var text = '';
    if (node == this.container) {
      text = this.getRightDocument(node.parentNode);
    }
    for (var current = node.nextSibling; current != null; current = current.nextSibling) {
      text += current.textContent;
    }
    return text;
  },

  getLeftDocument : function(node) {
    var text = '';
    if (node == this.container) {
      text = this.getLeftDocument(node.parentNode);
    }
    parent = node.parentNode;
    if (parent.childNodes) {
      for (var i = 0; i &lt; parent.childNodes.length &amp;&amp; parent.childNodes[i] != node; ++i) {
        text += parent.childNodes[i].textContent;
      }
    }
    return text;
  },

  computeContextFF : function() {
    var left = this.getLeftDocument(this.range.startContainer) + this.range.startContainer.textContent.substring(0, this.range.startOffset);
    var subLeft = '';
    var right = this.range.endContainer.textContent.substring(this.range.endOffset, this.range.endContainer.textContent.length) + this.getRightDocument(this.range.endContainer);
    var subRight = '';
    var offset = 0;
    var context = this.range.toString();
    var leftExpansion = 0;
    var rightExpansion = 0;
    while (subRight != right || subLeft != left) {
      var k = this.container.textContent.indexOf(context);
      var l = this.container.textContent.indexOf(context, k + 1);
      if (l == -1) {
        break;
      }
      leftExpansion = Math.min(left.length, leftExpansion + this.step);
      rightExpansion = Math.min(right.length, rightExpansion + this.step);
      subRight = right.substring(0, rightExpansion);
      subLeft = left.substring(left.length - leftExpansion, left.length);
    }
    this.selectionContext = subLeft + this.selectionText + subRight;
    this.selectionOffset = Math.max(subLeft.length, 0);
  },
  
  computeContextIE : function() {
    var containerInnerText = this.container.innerText;
    // copy the range to make the expanding on a range copy
    var cRange = this.range.duplicate();
    // while the selection appears more than once, expand the selection to left and right with one or more words and get its text
    var leftOffset = 0;
    // if we managed to expand anything (to prevent a loop where it's not unique but we can't expand)
    var expanded = true;
    while(!this.isUnique(containerInnerText, cRange.text) &amp;&amp; expanded) {
      var expanded = false;
      // expand left
      var initialLength = cRange.text.length;
      cRange.moveStart('word', -1);
      if (!this.isDescendantOrSelf(this.container, cRange.parentElement())) {
        // move back, cannot move to the left, cross fingers that this works the same in both directions
        cRange.moveStart('word', 1);
      } else {
        //update the offset with the word we just added
        leftOffset += cRange.text.length - initialLength;
        expanded = true;
      }

      // expand right
      cRange.moveEnd('word', 1);
      if (!this.isDescendantOrSelf(this.container, cRange.parentElement())) {
        // move back, cannot move to right, cross fingers that this works the same in both directions
        cRange.moveEnd('word', -1);
      } else {
        expanded = true;
      }
    }
    // is unique or we couldn't expand anymore, this is it, send it
    this.selectionContext = cRange.text;
    this.selectionOffset = leftOffset;
  },

  isUnique : function(subject, pattern) {
    var index1 = subject.indexOf(pattern);
    if (index1 &gt;= 0) {
      return subject.indexOf(pattern, index1 + 1) &lt; 0;
    }
    // assume (ass of u and me) that no encounter means unique
    return true;
  }
});

XWiki.Annotation = Class.create({
  // tab name of the annotations tab
  annTabname : 'Annotations',
  // whether current displayed doc is the rendered annotated document
  fetchedAnnotations : false,
  // the display annotations check box in the settings panel
  displayAnnotationsCheckbox : false,
  // the selection service used to detect and handle selection related functions on the document
  selectionService : false,

  initialize : function () {
    this.hookMenuButton();
    this.hookTabShortcut();
    this.hookTab();

    // add the delete listeners to the annotations in the annotations tab when the extra panels are loaded
    document.observe('xwiki:docextra:loaded', this.addDeleteListeners.bindAsEventListener(this));
    // register the key shortcuts for adding an annotation
    this.registerAddAnnotationShortcut();

    // and initialize the selectionService
    // TODO: get this container from a member or something, so that we're sure all functions use the same container
    this.selectionService = new XWiki.Selection($('xwikicontent'));
  },

  hookMenuButton : function() {
    var rightMenu = $('contentmenu').down('.rightmenu');
    // create and insert if it doesn't exist
    if (!rightMenu) {
      rightMenu = new Element('div', {'class':'rightmenu'});
      // insert it before the left menu
      var leftMenu = $('contentmenu').down('.leftmenu');
      if (leftMenu) {
        leftMenu.insert({before: rightMenu});
      } else {
        $('contentmenu').insert({bottom: rightMenu});
      }
    }
    // create the annotations button
    var annContainer = new Element('div', {'class': 'topmenuentry hasIcon', 'id': 'tmAnnotations'});
    var annLink = new Element('a', {'class': 'tme', 'href': '#' + this.annTabname});
    annLink.update("&lt;strong&gt;$msg.get('annotations.title')&lt;/strong&gt;");
    annContainer.insert({top: annLink});
    rightMenu.insert({bottom: annContainer});

    annLink.observe('click', this.toggleSettingsPanel.bind(this));
  },

  hookTabShortcut : function() {
    var shortcutsContainer = $('commentsshortcut').up();
    var annShortcut = new Element('span', {'id' : 'annotationsshortcut'}).update('&lt;a href="#' + this.annTabname + '"&gt;$msg.get("annotations.title")&lt;/a&gt; ');
    shortcutsContainer.insert({top: annShortcut});
    var separator = new Element('span', {'class' : 'separator'}).update('|');
    annShortcut.insert({after : separator});

    annShortcut.observe('click', XWiki.displayDocExtra.bind(XWiki, this.annTabname, 'annotationsinline.vm', true));
  },
  
  hookTab : function() {
    // the tab title
    var tabTitlesContainer = $('docExtrasTabsUl');
    var annTitle = new Element('li', {'id' : this.annTabname + 'tab'}).update('&lt;a href="#' + this.annTabname + '" id="' + this.annTabname + 'link"&gt;$msg.get("annotations.title")&lt;/a&gt;');
    tabTitlesContainer.insert({top: annTitle});

    annTitle.observe('click', XWiki.displayDocExtra.bind(XWiki, this.annTabname, 'annotationsinline.vm', true));

    // add tab pane here, to fill in with ajax call
    var tabPaneContainer = $('docextrapanes');
    var annPane = new Element('div', {'id' : this.annTabname + 'pane', 'class': 'hidden empty'});
    tabPaneContainer.insert({top: annPane});

    // add the anchor before the annotations pane
    var anchorsContainer = $('docextraanchors');
    anchorsContainer.insert({top : new Element('span', {'id' : this.annTabname + 'anchor'}).update("&amp;nbsp;")})
  },
  
  toggleSettingsPanel : function(event) {
    var menu = event.element();
    // prevent link
    event.stop();
    // if another click handling is in progress
    if (menu.disabled) {
      return;
    }
    if (!this.settingsPanel) {
      new Ajax.Request('$xwiki.getURL("AnnotationCode.Settings", "view", "xpage=plain")', {
        onCreate: function() {
          // disable the button
          menu.disabled = true;
          // show nice loading message at page bottom
          menu._x_notification = new XWiki.widgets.Notification("$msg.get('annotations.menu.loading')", "inprogress");
        },

        onSuccess: function(response) {
          $('contentmenu').insert({after: response.responseText});
          this.settingsPanel = $('contentmenu').next();
          // hide message at page bottom
          menu._x_notification.hide();
          // store the displayed annotations checkbox
          this.displayAnnotationsCheckbox = $('annotationsdisplay');
          this.attachSettingsListeners();
          $('tmAnnotations').toggleClassName('active');
        }.bind(this),
   
        onFailure: function(response) {
          var failureReason = response.statusText;
          if (response.statusText == '' /* No response */ || response.status == 12031 /* In IE */) {
            failureReason = 'Server not responding';
          }
          // show the error message at the bottom
          menu._x_notification.replace(new XWiki.widgets.Notification("$msg.get('annotations.menu.loaderror')" + failureReason, "error"));
        },

        on0: function (response) {
          response.request.options.onFailure(response);
        },

        onComplete: function() {
          // In the end: re-enable the button
          menu.disabled = false;
        }
      });
    } else {
      this.settingsPanel.toggleClassName('hidden');
      $('tmAnnotations').toggleClassName('active');
    }
  },

  attachSettingsListeners : function() {
    this.displayAnnotationsCheckbox.observe('click', function(event) {
      var visible = this.displayAnnotationsCheckbox.checked;
      // don't do anything if another call is in progress
      if (this.displayAnnotationsCheckbox.disabled) {
        return;
      }
      this.displayAnnotationsCheckbox.disabled = true;
      if (!this.fetchedAnnotations &amp;&amp; visible) {
        this.fetchAnnotations(true);
      } else {
        this.toggleAnnotations(visible);
        // and also enable back the checkbox
        this.displayAnnotationsCheckbox.disabled = false;
      }
    }.bindAsEventListener(this));
  },
  
  // check if I need this parameter or not
  toggleAnnotations : function(visible) {
    // don't standard toggle because we want to ensure it matches visible
    $$('#xwikicontent .annotation').invoke(visible ? 'addClassName' : 'removeClassName', 'annotation-highlight');
    //and hide all annotation markers
    $$('#xwikicontent .annotation-marker').invoke(visible ? 'removeClassName' : 'addClassName', 'hidden');
  },

  fetchAnnotations : function(andShow) {
    // TODO: fixme, get the URL in a less hardcoded way
    var getAnnotationsURL = '/xwiki/rest/wikis/' + XWiki.currentWiki + '/spaces/' + XWiki.currentSpace + '/pages/' + $$('meta[name=page]')[0].content + '/annotations?media=json';
    new Ajax.Request(getAnnotationsURL, {method: 'GET',
      onCreate: function() {
        // show nice loading message at page bottom
        this._x_notification = new XWiki.widgets.Notification("$msg.get('annotations.annotated.loading')", "inprogress");
      }.bind(this),

      onSuccess: function(response) {
        // TODO: check this response to see what's inside
        // hide message at page bottom
        this._x_notification.hide();
        // load the received annotated content in the page, along with annotations and annotations markers
        this.loadAnnotatedContent(response.responseJSON, andShow);
        // store the state of the annotations
        this.fetchedAnnotations = true;
        this.displayAnnotationsCheckbox.checked = true;
      }.bind(this),

      onFailure: function(response) {
        var failureReason = response.statusText;
        if (response.statusText == '' /* No response */ || response.status == 12031 /* In IE */) {
          failureReason = 'Server not responding';
        }
        // show the error message at the bottom
        this._x_notification.replace(new XWiki.widgets.Notification("$msg.get('annotations.annotated.loaderror')" + failureReason, "error"));
        this.displayAnnotationsCheckbox.checked = false;
      }.bind(this),

      on0: function (response) {
        response.request.options.onFailure(response);
      }.bind(this),

      onComplete: function() {
        // In the end: re-enable the checkbox
        this.displayAnnotationsCheckbox.disabled = false;
      }.bind(this)
    });
  },

  loadAnnotatedContent : function(annotatedContent, andShow, navigateToPane) {
    // TODO: store the annotated element in a different way, to have it the same in the instance (when it's an object prop for example)
    $('xwikicontent').update(annotatedContent.content);
    if (annotatedContent.annotations) {
      this.addAnnotationMarkers(annotatedContent.annotations);
    }
    if (andShow) {
      this.toggleAnnotations(true);
    }

    // and also handle the tab 'downstairs' when the annotations list changes
    var annotationsPane = $( this.annTabname + 'pane');
    // reset to initial state
    annotationsPane.update('');
    annotationsPane.addClassName('empty');
    if (!annotationsPane.hasClassName('hidden')) {
      // reload
      XWiki.displayDocExtra(this.annTabname, 'annotationsinline.vm', navigateToPane)
    }
  },

  addDeleteListeners : function() {
    $$(".annotation a.delete").each(function(item) {
      item.observe('click', function(event) {
        item.blur();
        event.stop();
        if (item.disabled) {
          // Do nothing if the button was already clicked and it's waiting for a response from the server.
          return;
        } else {
          new XWiki.widgets.ConfirmedAjaxRequest(
            item.href,
            {
              onCreate : function() {
                // Disable the button, to avoid a cascade of clicks from impatient users
                item.disabled = true;
              },
              onSuccess : function(response) {
                // reload the received annotated content, with scroll to tab
                this.loadAnnotatedContent(response.responseJSON.annotatedContent, this.displayAnnotationsCheckbox.checked, true);
              }.bind(this),
              onComplete : function() {
                // In the end: re-enable the button
                item.disabled = false;
              }
            },
            /* Interaction parameters */
            {
               confirmationText: "$msg.get('annotations.action.delete.confirm')",
               progressMessageText : "$msg.get('annotations.action.delete.inProgress')",
               successMessageText : "$msg.get('annotations.action.delete.done')",
               failureMessageText : "$msg.get('annotations.action.delete.failed')"
            }
          );
        }
      }.bindAsEventListener(this));
    }.bind(this));
  },

  addAnnotationMarkers : function(annotations) {
    annotations.each(function(item){
      // get the last span of this annotation
      var allSpans = $$('#xwikicontent [class~=ID' + item.annotationId + ']');
      if (allSpans.size() == 0) {
        return;
      }
      var lastSpan = allSpans[allSpans.size() - 1];
      // create the annotation markers hidden by default, since annotations are added on the document hidden by default
      var markerSpan = new Element('span', {'id': 'ID' + item.annotationId, 'class' : 'hidden annotation-marker ' + item.state});
      lastSpan.insert({after: markerSpan});
    });
  }, 

  registerAddAnnotationShortcut : function() {
    var shortcuts = ['Ctrl+M', 'Meta+M', 'Ctrl+I', 'Meta+I'];
    var method = this.addAnnotation;
    for (var i = 0; i &lt; shortcuts.size(); ++i) {
      if (Prototype.Browser.IE || Prototype.Browser.WebKit) {
        shortcut.add(shortcuts[i], method.bindAsEventListener(this), {type: 'keyup'});
      } else {
        shortcut.add(shortcuts[i], method.bindAsEventListener(this), {type: 'keypress'});
      }
    }
  },

  /**
   * Execute the add annotation shortcut: get selection, compute context, open dialog, register listeners.
   */
  addAnnotation : function() {
    // parse the selection on the xwiki content container
    this.selectionService.computeSelection($('xwikicontent'));
    var selectionText = this.selectionService.selectionText;
    if (!selectionText) {
      // show an 'invalid selection message'
      new XWiki.widgets.Notification("$msg.get('annotations.action.create.selection.invalid')", "error");
    } else {
      this.selectionService.computeContext();
      // fetch the creation for this annotation and display it at the position of the selection
      new Ajax.Request('$xwiki.getURL("AnnotationCode.CreateForm")', {
        parameters: {
          'xpage' : 'plain',
          'selection' : encodeURIComponent(selectionText),
          'selectionContext' : encodeURIComponent(this.selectionService.selectionContext),
          'selectionOffset' : this.selectionService.selectionOffset,
          'space' : encodeURIComponent(XWiki.currentSpace),
          'page' : encodeURIComponent($$('meta[name=page]')[0].content)
        },
        onCreate: function() {
          // show nice loading message at page bottom
          this._x_notification = new XWiki.widgets.Notification("$msg.get('annotations.action.create.form.loading')", "inprogress");
        }.bind(this),

        onSuccess: function(response) {
          // display the annotation creation form
          this.displayAnnotationCreationForm(response.responseText);
          // and add the button observers
          this.createPanel.down('input[type=submit]').observe('click', this.onAnnotationAdd.bindAsEventListener(this));
          this.createPanel.down('input[type=reset]').observe('click', this.hideAnnotationCreationForm.bindAsEventListener(this));
          // hide the notification message
          this._x_notification.hide();
        }.bind(this),
   
        onFailure: function(response) {
          var failureReason = response.statusText;
          if (response.statusText == '' /* No response */ || response.status == 12031 /* In IE */) {
            failureReason = 'Server not responding';
          }
          // show the error message at the bottom
          this._x_notification.replace(new XWiki.widgets.Notification("$msg.get('annotations.action.create.form.loaderror')" + failureReason, "error"));
        }.bind(this),

        on0: function (response) {
          response.request.options.onFailure(response);
        }.bind(this)
      });
    }
  }, 

  displayAnnotationCreationForm : function(panelContent) {
    // create an element with the form
    this.createPanel = new Element('div', {'style' : 'position: absolute;'});
    // make it hidden for the moment
    this.createPanel.toggleClassName('hidden');
    // TODO: get this color from the color theme
    this.selectionService.highlightSelection("#FFEE99");
    this.selectionService.container.insert({bottom : this.createPanel});
    // set the position of the panel on the screen
    this.selectionService.positionPanelNextToSelection(this.createPanel);
    // put the content in
    this.createPanel.update(panelContent);
    // make it visible
    this.createPanel.toggleClassName('hidden');
    // set the focus in the first element of type input
    this.createPanel.select('form').first().focusFirstElement();
    // TODO: make it listen to escape and close it if it's the case
  },

  hideAnnotationCreationForm : function() {
    // make the dialog go away
    this.createPanel.remove();
    // rollback selection coloring
    this.selectionService.removeSelectionHighlight();
  }, 

  onAnnotationAdd : function(event) {
    // don't submit
    event.stop();
    var form = this.createPanel.down('form');
    var formData = new Hash(form.serialize(true));
    // aaand submit
    new Ajax.Request(form.action, {
      method : form.method,
      parameters : formData,
      onCreate : function() {
        form._x_notification = new XWiki.widgets.Notification("$msg.get("annotations.action.create.loading")", "inprogress");
      },
      onSuccess : function (response) {
        // TODO: check response code
        this.loadAnnotatedContent(response.responseJSON.annotatedContent, this.displayAnnotationsCheckbox.checked);
        this.fetchedAnnotations = true;
        form._x_notification.replace(new XWiki.widgets.Notification("$msg.get('annotations.action.create.success')", "done"));
      }.bind(this),
      onFailure : function(response) {
        this.hideAnnotationCreationForm();
        this._x_notification.replace(new XWiki.widgets.Notification("$msg.get('annotations.action.create.loaderror')" + failureReason, "error"));
      }.bind(this),
      on0 : function (response) {
        response.request.options.onFailure(response);
      }
    });
  }
});

// TODO: add conditions here to load only on activated spaces and only if annotations are activated in the config document
document.observe('dom:loaded', function() {
  new XWiki.Annotation();
});</code>
</property>
<property>
<name>Annotation Javascript</name>
</property>
<property>
<parse>1</parse>
</property>
<property>
<use>always</use>
</property>
</object>
<content>
</content></xwikidoc>